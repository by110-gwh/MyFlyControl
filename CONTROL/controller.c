#include "controller.h"
#include "remote_control.h"
#include "ahrs_aux.h"
#include "attitude_self_stabilization.h"
#include "high_attitude_stabilization.h"
#include "horizontal_attitude_stabilization.h"
#include "route_plan_attitude_stabilization.h"
#include "angle_control.h"
#include "gyro_control.h"
#include "high_control.h"
#include "horizontal_control.h"
#include "motor_output.h"
#include "route_plan_task.h"
#include "beep_task.h"
#include "navigation.h"
#include "main_task.h"

uint8_t controller_state;

/**********************************************************************************************************
*函 数 名: control_init
*功能说明: 控制器初始化
*形    参: 无
*返 回 值: 无
**********************************************************************************************************/
void controller_init()
{
    angle_control_init();
    gyro_control_init();
    high_control_init();
    horizontal_control_init();
    controller_state = 0;
}

/**********************************************************************************************************
*函 数 名: constrain_float
*功能说明: 限制最大最小值
*形    参: 要限制的值 最小值 最大值
*返 回 值: 输出值
**********************************************************************************************************/
static float constrain_float(float amt, float low, float high)
{
	return ((amt) < (low) ? (low) : ((amt) > (high)? (high) : (amt)));
}

/**********************************************************************************************************
*函 数 名: throttle_angle_compensate
*功能说明: 油门倾角补偿
*形    参: 原有门量
*返 回 值: 补偿后的油门量
**********************************************************************************************************/
uint16_t throttle_angle_compensate(uint16_t throttle)
{
	uint16_t throttle_output;
	float CosPitch_CosRoll = Cos_Pitch * Cos_Roll;
	//补偿限制
	if(CosPitch_CosRoll <= 0.50f)
		CosPitch_CosRoll = 0.50f;
	//大于起转油门量
	if(throttle >= 1000) {
		//油门倾角补偿
		throttle_output = 1000 + (throttle - 1000) / CosPitch_CosRoll;
		throttle_output = (uint16_t)(constrain_float(throttle_output, 1000, 2000));
	} else
		throttle_output = throttle;
	return throttle_output;
}

/**********************************************************************************************************
*函 数 名: controller_run
*功能说明: 控制器执行
*形    参: 无
*返 回 值: 无
**********************************************************************************************************/
void controller_run()
{
    if (fly_task_num && controller_state != 5) {
        route_plan_attitude_stabilization_init();
        controller_state = 5;
    } else if (!fly_task_num && Throttle_Control < 100) {
        if (rc_raw_data[6] > 1500) {
            route_plan_attitude_stabilization_init();
            controller_state = 4;
        } else if (rc_raw_data[4] < 1250) {
            attitude_self_stabilization_init();
            controller_state = 1;
        } else if (rc_raw_data[4] < 1750) {
            high_attitude_stabilization_init();
            controller_state = 2;
        } else {
            horizontal_attitude_stabilization_init();
            controller_state = 3;
        }
        gyro_pid_integrate_reset();
        angle_pid_integrate_reset();
    }
    
    //纯姿态模式
    if (controller_state == 1) {
        //纯姿态控制器
        attitude_self_stabilization_control();
    //定高模式
    } else if (controller_state == 2) {
        if (Throttle_Control < HOLD_THROTTLE)
            attitude_self_stabilization_control();
        else
            high_attitude_stabilization_control();
    //定点模式
    } else if (controller_state == 3) {
        if (Throttle_Control < HOLD_THROTTLE)
            attitude_self_stabilization_control();
        else
            horizontal_attitude_stabilization_control();
    } else if (controller_state == 4) {
        if (Throttle_Control < 100) {   
            pitch_gyro_pid_data.control_output = 0;
            roll_gyro_pid_data.control_output = 0;
            yaw_gyro_pid_data.control_output = 0;
            throttle_motor_output = 1000;
        } else {
            route_plan_attitude_stabilization_control();
        }
    } else if (controller_state == 5) {
        route_plan_attitude_stabilization_control();
    }
}
